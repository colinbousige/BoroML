#!/usr/local/bin/python3

"""
Compute GDOS from a LAMMPS dump file containing the velocities.
Dump file **must** be generated by: `dump dmpname all custom dumptime name.lammpstrj id element x y z vx vy vz`.
Outputs a tidy table in csv format to stdout.
"""

import numpy as np
import sys
from ase import *
import argparse
from pwtools.pydos import pdos
from tqdm import tqdm

def read_lammps(filename: str):
    """
    Read input.data file and return a list of Atoms objects and the timesteps
    """
    def read_block(lines, begin: int, N: int, a: float, b: float, c: float):
        """
        Read block of structure in input.data that have been read in to `lines`
        """
        lattice = np.array([a,b,c])
        pos = np.array([[i for i in lines[j].split(' ') if i][2:5] for j in range(begin+1, begin+N+1)], dtype=float)
        vel = np.array([[i for i in lines[j].split(' ') if i][5:8] for j in range(begin+1, begin+N+1)], dtype=float)
        symb = np.array([[i for i in lines[j].split(' ') if i][1] for j in range(begin+1, begin+N+1)])
        out = Atoms(symbols   = symb,
                    positions = pos, 
                    cell      = lattice, pbc=True)
        out.set_velocities(vel)
        return(out)   
    # # # # # # # # # # # # 
    with open(filename, 'r') as f:
        lines = f.read().splitlines()
    begin = np.array([i for i, x in enumerate(lines) if 'ITEM: ATOMS' in x])
    Natoms = np.array([lines[i+1] for i, x in enumerate(lines) if x == 'ITEM: NUMBER OF ATOMS'], dtype=int)
    a = np.array([lines[i+1].split(" ") for i, x in enumerate(lines) if 'ITEM: BOX BOUNDS' in x], dtype=float); a = a[:,1]-a[:,0]
    b = np.array([lines[i+2].split(" ") for i, x in enumerate(lines) if 'ITEM: BOX BOUNDS' in x], dtype=float); b = b[:,1]-b[:,0]
    c = np.array([lines[i+3].split(" ") for i, x in enumerate(lines) if 'ITEM: BOX BOUNDS' in x], dtype=float); c = c[:,1]-c[:,0]
    TS = np.array([lines[i+1] for i, x in enumerate(lines) if x == 'ITEM: TIMESTEP'], dtype=float)
    atoms = [read_block(lines, beg, N, aa,bb,cc) for beg,N,aa,bb,cc in tqdm(zip(begin, Natoms,a,b,c), desc=f'Reading LAMMPS trajectory', total=len(a))]
    return(atoms, TS)

def main(args):
    input = args.input
    units = args.units
    timestep = args.timestep
    outUnit = args.outUnit
    pad = args.pad
    total = args.total
    
    if units not in ['metal', 'real']:
        raise ValueError("units must be 'metal' or 'real'.")
    if outUnit not in ['meV', 'THz', 'cm-1']:
        raise ValueError("outUnit must be 'meV', 'THz', or 'cm-1'.")
    coefout = 1.0
    if outUnit == 'meV':
        coefout = 4.136
    if outUnit == 'cm-1':
        coefout = 33.356
    # Read trajectory
    sys.stderr.write(f"Working on {input}:\n");sys.stderr.flush()
    traj, time = read_lammps(input)
    # Make sure times are in ps:
    if units=='metal':
        coef=1.0
    else:
        coef=1.0e-3
    time = time*coef*timestep
    # Get timestep
    dt = (time[1]-time[0])
    # Get atom types
    atsymb = list(set(traj[0].get_chemical_symbols()))
    # Computing all partial GDOSs
    # Write csv output header
    sys.stdout.write(f'element,freq.{outUnit},dos\n')
    for at in atsymb:
        # Get partial trajectory
        atID = np.array(traj[0].get_chemical_symbols()) == at
        trajat = [t[atID] for t in traj]
        # Get velocities
        velat = np.array([t.get_velocities() for t in trajat])
        # Compute GDOS
        sys.stderr.write(f"Computing {at} GDOS...");sys.stderr.flush()
        freq,gdos = pdos(velat, m=trajat[0].get_masses(), dt=dt, method='direct', npad=pad)
        sys.stderr.write("Done.\n");sys.stderr.flush()
        # Output to stdout
        for f,d in zip(freq,gdos):
            sys.stdout.write(f'{at},{f*coefout},{d}\n')
    if total:
        # Get all velocities
        vel = np.array([t.get_velocities() for t in traj])
        # Compute GDOS
        sys.stderr.write(f"Computing total GDOS...");sys.stderr.flush()
        freq,gdos = pdos(vel, m=traj[0].get_masses(), dt=dt, method='direct', npad=pad)
        sys.stderr.write("Done.\n");sys.stderr.flush()
        # Output to stdout
        for f,d in zip(freq,gdos):
            sys.stdout.write(f'Total,{f*coefout},{d}\n')
    
    

class ArgumentParserWithDefaults(argparse.ArgumentParser):
    def add_argument(self, *args, help=None, default=None, **kwargs):
        if help is not None:
            kwargs['help'] = help
        if default is not None and args[0] != '-h':
            kwargs['default'] = default
            if help is not None:
                kwargs['help'] += '\n\033[93mDefault: {}\033[0m'.format(default)
        super().add_argument(*args, **kwargs)

def get_parser():
    """ The argument parser of the command-line version """
    parser = ArgumentParserWithDefaults(formatter_class=argparse.RawTextHelpFormatter,
    description="""
\033[93m\033[1mCompute GDOS from a LAMMPS dump file containing the velocities.\nDump file **must** be generated by: `dump dmpname all custom dumptime name.lammpstrj id element x y z vx vy vz`.\nOutputs a tidy table in csv format to stdout.\033[0m
""")
    parser.add_argument('--input', '-in',
                        help    = 'Input file.')
    parser.add_argument('--units', '-u',
                        help    = f"LAMMPS units used. Must be `metal` or `real`.",
                        default = "metal")
    parser.add_argument('--timestep', '-ts',
                        type    = float,
                        help    = f"LAMMPS `timestep` parameter used for the MD trajectory.",
                        default = 1.0e-4)
    parser.add_argument('--outUnit', '-ou',
                        help    = f"Units of the frequency output. Must be one of 'meV', 'THz', 'cm-1'.",
                        default = 'cm-1')
    parser.add_argument('--pad', '-p',
                        type    = int,
                        help    = f"Padding for GDOS computation.",
                        default = 10)
    parser.add_argument('--total', '-t',
                        help    = 'Compute total GDOS on top of partial ones?',
                        default = False, 
                        action  = "store_true")

    parser.usage = f'\033[93m{parser.format_usage()[7:]}\033[0m'
    return parser


if __name__ == "__main__":
    """ Run as a stand-alone script """

    parser = get_parser()       # Start the command-line argument parsing
    args = parser.parse_args()  # Read the command-line arguments
    main(args)                  # run the command-line version
    
